rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ─── Helpers ─────────────────────────────────────────────────────────────

    function isAuth() {
      return request.auth != null;
    }

    function isUser(uid) {
      return isAuth() && request.auth.uid == uid;
    }
  
    function isParticipant(participantIds) {
      return isAuth() && request.auth.uid in participantIds;
    }

    function isValidString(value, minLen, maxLen) {
      return value is string 
        && value.size() >= minLen 
        && value.size() <= maxLen;
    }

    function isValidStatus(status, allowedStatuses) {
      return status is string && status in allowedStatuses;
    }

    // ─── Users ────────────────────────────────────────────────────────────────

    match /users/{userId} {
      allow read: if isAuth();
      
      allow create: if isUser(userId)
        && request.resource.data.keys().hasAll(['email', 'createdAt'])
        && isValidString(request.resource.data.email, 3, 254);
      
      allow update: if isUser(userId)
        && request.resource.data.keys().hasAll(['email', 'createdAt'])
        && request.resource.data.email == resource.data.email;
      
      allow delete: if isUser(userId);
    }

    // ─── Items ────────────────────────────────────────────────────────────────

    match /items/{itemId} {
      allow read: if isAuth();

      allow create: if isAuth()
        && request.resource.data.ownerId == request.auth.uid
        && request.resource.data.keys().hasAll([
             'ownerId', 'title', 'description', 'category', 
             'condition', 'images', 'status', 'createdAt'
           ])
        && isValidString(request.resource.data.title, 1, 200)
        && isValidString(request.resource.data.description, 1, 5000)
        && isValidString(request.resource.data.category, 1, 100)
        && isValidString(request.resource.data.condition, 1, 50)
        && request.resource.data.images is list
        && request.resource.data.images.size() > 0
        && request.resource.data.images.size() <= 10
        && isValidStatus(request.resource.data.status, ['available', 'pending', 'traded']);

      allow update: if isAuth() 
        && resource.data.ownerId == request.auth.uid
        && request.resource.data.ownerId == resource.data.ownerId
        && request.resource.data.createdAt == resource.data.createdAt
        && (
          // Allow status updates
          (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'updatedAt']))
          // Allow full updates by owner
          || (
            isValidString(request.resource.data.title, 1, 200)
            && isValidString(request.resource.data.description, 1, 5000)
            && request.resource.data.images.size() > 0
            && request.resource.data.images.size() <= 10
          )
        );
      
      allow delete: if isAuth() && resource.data.ownerId == request.auth.uid;
    }

    // ─── Swipe Sessions ───────────────────────────────────────────────────────

    match /swipeSessions/{sessionId} {
      allow read: if isAuth() && resource.data.userId == request.auth.uid;
      
      allow create: if isAuth()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.keys().hasAll([
             'userId', 'tradeAnchorId', 'createdAt', 'lastActivityAt', 'swipes'
           ])
        && request.resource.data.swipes is list
        && request.resource.data.tradeAnchorId is string
        && request.resource.data.tradeAnchorId.size() > 0;
      
      allow update: if isAuth() 
        && resource.data.userId == request.auth.uid
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.tradeAnchorId == resource.data.tradeAnchorId
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.swipes is list;
      
      allow delete: if isAuth() && resource.data.userId == request.auth.uid;
    }

    // ─── Trade Offers ─────────────────────────────────────────────────────────

    match /tradeOffers/{offerId} {
      // Both the offering user and the target item owner can read
      allow read: if isAuth()
        && (resource.data.offeringUserId == request.auth.uid
            || resource.data.targetItemOwnerId == request.auth.uid);

      // Only the offering user can create
      allow create: if isAuth()
        && request.resource.data.offeringUserId == request.auth.uid
        && request.resource.data.tradeAnchorOwnerId == request.auth.uid
        && request.resource.data.keys().hasAll([
             'tradeAnchorId', 'tradeAnchorOwnerId', 'targetItemId',
             'targetItemOwnerId', 'offeringUserId', 'createdAt', 'updatedAt', 'status'
           ])
        && request.resource.data.tradeAnchorId is string
        && request.resource.data.targetItemId is string
        && request.resource.data.tradeAnchorId != request.resource.data.targetItemId
        && request.resource.data.offeringUserId != request.resource.data.targetItemOwnerId
        && isValidStatus(request.resource.data.status, ['pending', 'read', 'accepted', 'declined', 'completed']);

      // Either party can update (accept / decline / mark read / complete)
      allow update: if isAuth()
        && (resource.data.offeringUserId == request.auth.uid
            || resource.data.targetItemOwnerId == request.auth.uid)
        && request.resource.data.tradeAnchorId == resource.data.tradeAnchorId
        && request.resource.data.targetItemId == resource.data.targetItemId
        && request.resource.data.offeringUserId == resource.data.offeringUserId
        && request.resource.data.targetItemOwnerId == resource.data.targetItemOwnerId
        && request.resource.data.tradeAnchorOwnerId == resource.data.tradeAnchorOwnerId
        && request.resource.data.createdAt == resource.data.createdAt
        && isValidStatus(request.resource.data.status, ['pending', 'read', 'accepted', 'declined', 'completed'])
        && (
          // Target owner can accept or decline
          (request.auth.uid == resource.data.targetItemOwnerId 
            && request.resource.data.status in ['read', 'accepted', 'declined'])
          // Offering user can mark as read
          || (request.auth.uid == resource.data.offeringUserId 
            && request.resource.data.status in ['read'])
          // Either can add themselves to completedBy array when status is accepted
          || (resource.data.status == 'accepted'
            && (!resource.data.keys().hasAny(['completedBy']) 
                || request.auth.uid in request.resource.data.get('completedBy', []))
            && request.resource.data.get('completedBy', []) is list
            && request.resource.data.get('completedBy', []).size() <= 2)
          // Status can be completed when both users are in completedBy
          || (resource.data.status == 'accepted'
            && request.resource.data.status == 'completed'
            && request.resource.data.get('completedBy', []).size() == 2
            && resource.data.offeringUserId in request.resource.data.get('completedBy', [])
            && resource.data.targetItemOwnerId in request.resource.data.get('completedBy', []))
        );

      allow delete: if false; // Trade offers should not be deleted
    }

    // ─── Notifications ────────────────────────────────────────────────────────

    match /notifications/{notificationId} {
      allow read: if isAuth() && resource.data.userId == request.auth.uid;
      
      allow create: if isAuth()
        && request.resource.data.keys().hasAll(['userId', 'type', 'read', 'createdAt', 'data'])
        && isValidStatus(request.resource.data.type, ['trade_offer', 'message', 'system'])
        && request.resource.data.read == false
        && request.resource.data.data is map;
      
      allow update: if isAuth() 
        && resource.data.userId == request.auth.uid
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.type == resource.data.type
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.read is bool;
      
      allow delete: if isAuth() && resource.data.userId == request.auth.uid;
    }

    // ─── Conversations ────────────────────────────────────────────────────────

    match /conversations/{conversationId} {
      // Participants can read their own conversations
      allow read: if isAuth()
        && request.auth.uid in resource.data.participantIds;

      // A conversation can be created by either participant
      allow create: if isAuth()
        && request.auth.uid in request.resource.data.participantIds
        && request.resource.data.participantIds.size() == 2
        && request.resource.data.participantIds[0] != request.resource.data.participantIds[1]
        && request.resource.data.tradeOfferId is string
        && request.resource.data.tradeOfferId.size() > 0
        && request.resource.data.tradeAnchorId is string
        && request.resource.data.targetItemId is string
        && request.resource.data.keys().hasAll([
             'tradeOfferId', 'participantIds', 'tradeAnchorId', 'targetItemId',
             'createdAt', 'lastMessageAt', 'lastMessageText', 'unreadCount'
           ])
        && request.resource.data.unreadCount is map
        && request.resource.data.lastMessageText is string;

      // Only participants can update (unread counts, last message preview, etc.)
      allow update: if isParticipant(resource.data.participantIds)
        && request.resource.data.participantIds == resource.data.participantIds
        && request.resource.data.tradeOfferId == resource.data.tradeOfferId
        && request.resource.data.tradeAnchorId == resource.data.tradeAnchorId
        && request.resource.data.targetItemId == resource.data.targetItemId
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.unreadCount is map
        && request.resource.data.lastMessageText is string;

      // Conversations cannot be deleted (for record keeping)
      allow delete: if false;

      // ── Messages subcollection ──────────────────────────────────────────────

      match /messages/{messageId} {
        // Only participants can read messages
        allow read: if isAuth()
          && request.auth.uid in
             get(/databases/$(database)/documents/conversations/$(conversationId))
               .data.participantIds;

        // Only participants can send messages, and only as themselves
        allow create: if isAuth()
          && request.auth.uid in
             get(/databases/$(database)/documents/conversations/$(conversationId))
               .data.participantIds
          && request.auth.uid == request.resource.data.senderId
          && request.resource.data.keys().hasAll([
               'conversationId', 'senderId', 'text', 'createdAt', 'readBy'
             ])
          && request.resource.data.conversationId == conversationId
          && isValidString(request.resource.data.text, 1, 2000)
          && request.resource.data.readBy is list
          && request.resource.data.readBy.size() >= 0
          && request.resource.data.readBy.size() <= 2;

        // Participants can update messages (e.g. mark as read)
        allow update: if isAuth()
          && request.auth.uid in
             get(/databases/$(database)/documents/conversations/$(conversationId))
               .data.participantIds
          && request.resource.data.conversationId == resource.data.conversationId
          && request.resource.data.senderId == resource.data.senderId
          && request.resource.data.text == resource.data.text
          && request.resource.data.createdAt == resource.data.createdAt
          && request.resource.data.readBy is list;

        // Messages cannot be deleted (for record keeping)
        allow delete: if false;
      }
    }
  }
}